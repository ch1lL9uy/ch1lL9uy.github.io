---
title: Bronco CTF 2025 - REV
date: 2025-2-17 10:50:00 +0700
categories: [rev]
tag: [Reverse Engineering, Bronco CTF]
---

## Actual Reversing
**File**: [here](/assets/Bronco%20CTF%202025/Actual%20Reversing.zip)            

![alt text](/assets/Bronco%20CTF%202025/image.png)                       

First, let's look at the code:        
```c
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char i; // [rsp+7h] [rbp-59h]
  int v5; // [rsp+8h] [rbp-58h]
  int v6; // [rsp+Ch] [rbp-54h]
  char s[72]; // [rsp+10h] [rbp-50h] BYREF
  unsigned __int64 v8; // [rsp+58h] [rbp-8h]

  v8 = __readfsqword(0x28u);
  puts("Welcome to the transformer! We take what you have, and make it into what you have always wanted!");
  printf("What do you have to offer?\n> ");
  fgets(s, 64, _bss_start);
  s[strcspn(s, "\n")] = 0;
  v5 = 0;
  v6 = 0;
  while ( s[v5] )
  {
    for ( i = s[v5]; i; i >>= 1 )
      v6 += i & 1;
    ++v5;
  }
  if ( v6 == 108 )
  {
    puts("Here's my perscription:");
    perscribe(s);
    printf("%s", TRUTH);
  }
  else
  {
    puts("That'll NEVER turn into what you want!");
  }
  return 0;
}
```                     

In this part, the program calculates the total number of 1-bits in the input and store it in `v6`             
if `v6` == 108 then the program will process the input at `perscribe(s)` and return the result as shown in `log.txt`          

Check `perscribe(s)`:       
```c      
unsigned __int64 __fastcall perscribe(char *a1)
{
  void *v1; // rsp
  __int64 v3; // [rsp+0h] [rbp-60h] BYREF
  char *s; // [rsp+8h] [rbp-58h]
  int i; // [rsp+18h] [rbp-48h]
  int j; // [rsp+1Ch] [rbp-44h]
  int k; // [rsp+20h] [rbp-40h]
  int v8; // [rsp+24h] [rbp-3Ch]
  int v9; // [rsp+28h] [rbp-38h]
  int v10; // [rsp+2Ch] [rbp-34h]
  int v11; // [rsp+30h] [rbp-30h]
  int v12; // [rsp+34h] [rbp-2Ch]
  __int64 v13; // [rsp+38h] [rbp-28h]
  __int64 *v14; // [rsp+40h] [rbp-20h]
  unsigned __int64 v15; // [rsp+48h] [rbp-18h]

  s = a1;
  v15 = __readfsqword(0x28u);
  v8 = strlen(TRUTH);
  v9 = 8 * v8;
  v13 = 8 * v8 - 1LL;
  v1 = alloca(16 * ((8 * v8 + 15LL) / 0x10uLL));
  v14 = &v3;
  for ( i = 0; i < 8 * v8; ++i )
    *((_BYTE *)v14 + i) = 0;
  v10 = strlen(s);
  for ( i = 0; i < v10; ++i )
  {
    for ( j = 0; j <= 7; ++j )
    {
      v11 = 1 << j;
      if ( ((1 << j) & s[i]) != 0 )
      {
        v12 = 8 * i + j;
        for ( k = 0; ((TRUTH[k >> 3] >> (k & 7)) & 1) == 0 || *((_BYTE *)v14 + k); ++k )
          ;
        printf("Take %d of these, then\n", k - v12);
        *((_BYTE *)v14 + k) = 1;
      }
    }
  }
  puts("You're done!");
  return v15 - __readfsqword(0x28u);
}
```

The idea is to perform bruteforce and compare the value with the `log.txt`          

**Script**      
```python
import string

charset = string.ascii_lowercase + "_{}?" + string.ascii_uppercase + string.digits

log = open('log.txt', 'r').read().split("\n")
log = log[1:-2]
log_cnt = 0

TRUTH = "Can birds even understand me?"
v14 = [0] * (len(TRUTH) * 8)

flag = ""
i = 0
while '}' not in flag:
    for c in charset:
        t = False
        b = bin(ord(c))[2:][::-1]
        cnt = 0
        check = []
        prev = v14[:]
        for j in range(len(b)):
            if b[j] == '1':
                v12 = 8*i + j
                k = 0
                while ((ord(TRUTH[k>>3]) >> (k&7)) & 1 == 0 or prev[k]):
                    k += 1
                s = str(f"Take {k-v12} of these, then")
                check.append(s)
                prev[k] = 1
        if check == log[log_cnt : log_cnt + len(check)]:
            t = True
            break

    if t:   
        flag += c
        v14 = prev[:]
        print(f"Current: {flag}")
        log_cnt += len(check)

    i += 1
```
`Flag: bronco{r3v3r5ed_3n0ugh?}`